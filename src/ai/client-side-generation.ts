/**
 * @fileOverview A client-side utility for generating images directly from the browser.
 * This file provides a function to interact with the Google AI Gemini API for image generation
 * without using the server-side Genkit flow. It's intended for use in static deployments
 * where the user provides their own API key.
 *
 * - clientSideGenerate: A function that takes the node graph and a user-provided API key to generate an image.
 */

import type { ImageGenerationInput, ImageGenerationOutput } from './flows/image-generation-flow';

const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent";

const generateImageWithPrompt = async (prompt: string, apiKey: string, inputImage?: string): Promise<string> => {
    const parts: any[] = [];
    if (inputImage) {
        // The API expects a specific format for inline data.
        // It needs the raw base64 data and the mime type separately.
        const [header, base64Data] = inputImage.split(',');
        const mimeType = header.match(/:(.*?);/)?.[1];
        if (!mimeType || !base64Data) {
            throw new Error("Invalid input image data URI format.");
        }
        parts.push({
            inline_data: {
                mime_type: mimeType,
                data: base64Data
            }
        });
    }
    parts.push({ text: prompt });
    
    const response = await fetch(`${API_URL}?key=${apiKey}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ contents: [{ parts }] }),
    });

    if (!response.ok) {
        const errorBody = await response.json();
        const errorMessage = errorBody.error?.message || 'An unknown API error occurred.';
        
        if (response.status === 400 || response.status === 403) {
             throw new Error(`Invalid API Key or API not enabled. Please check your key and ensure the 'Generative Language API' is enabled in your Google Cloud project. Details: ${errorMessage}`);
        }
        
        console.error("Google AI API Error:", errorBody);
        throw new Error(errorMessage);
    }

    const data = await response.json();
    
    // Check for safety blocks or other reasons for no content
    if (!data.candidates || data.candidates.length === 0) {
        const blockReason = data.promptFeedback?.blockReason;
        if (blockReason) {
            throw new Error(`Image generation was blocked for safety reasons: ${blockReason}. Please adjust your prompt.`);
        }
        throw new Error('The API returned no image candidates. Your prompt might be too vague or violate a policy.');
    }

    const generatedContent = data.candidates[0]?.content?.parts?.find((p: any) => p.inline_data);

    if (!generatedContent) {
        // Sometimes the API might return a text block explaining why it couldn't generate an image.
        const textBlock = data.candidates[0]?.content?.parts?.find((p: any) => p.text);
        if (textBlock?.text) {
             throw new Error(`Image generation failed: ${textBlock.text}`);
        }
        throw new Error('No image was generated by the API. The response was empty.');
    }
    
    const { mime_type, data: base64Data } = generatedContent.inline_data;
    return `data:${mime_type};base64,${base64Data}`;
};


export async function clientSideGenerate(
  { nodes, step, lastResult }: ImageGenerationInput,
  apiKey: string
): Promise<ImageGenerationOutput> {
  const newResult: Partial<ImageGenerationOutput> = { ...lastResult };

  if (step === 1) { // Generate Input Image
    const cameraNode = nodes.find(n => n.type === 'camera-input' && n.value);
    if (cameraNode) {
      newResult.inputImage = cameraNode.value;
    } else {
      newResult.inputImage = await generateImageWithPrompt(
        "abstract gray and white noise pattern, 50% gray",
        apiKey
      );
    }
  }

  if (step === 2) { // Apply Manipulations
    const manipulationNodes = nodes.filter(n => ['pixel-noise', 'pixel-brightness', 'pixel-color', 'canny-edge'].includes(n.type));
    let manipulationPromptParts: string[] = ["Apply the following manipulations to the image:"];

    if (manipulationNodes.length > 0) {
      manipulationNodes.forEach(node => {
        switch (node.type) {
          case 'pixel-noise':
            manipulationPromptParts.push(`apply ${node.value}% pixel noise.`);
            break;
          case 'pixel-brightness':
            manipulationPromptParts.push(`adjust brightness by ${node.value}%.`);
            break;
          case 'pixel-color':
            manipulationPromptParts.push(`add a color tint of (${node.value.r}, ${node.value.g}, ${node.value.b}).`);
            break;
          case 'canny-edge':
            manipulationPromptParts.push(`apply Canny edge detection with a threshold of ${node.value}.`);
            break;
        }
      });
    } else {
      manipulationPromptParts.push("no manipulations, return the original image.");
    }
    
    const manipulatedImage = await generateImageWithPrompt(
      manipulationPromptParts.join(' '),
      apiKey,
      newResult.inputImage
    );
    newResult.manipulatedImage = manipulatedImage;
    newResult.generativeModelInputImage = manipulatedImage;
  }

  if (step === 3) { // Generate Final Image
    const finalPromptNodes = nodes.filter(n => ['text-prompt', 'setting-diffusion', 'setting-seed', 'meta-node'].includes(n.type));
    
    let finalPromptParts: string[] = [];
    if (finalPromptNodes.length === 0) {
      finalPromptParts.push("A stunningly beautiful mushroom, glowing with bioluminescence in a dark forest, cinematic, hyperrealistic.");
    } else {
      finalPromptNodes.forEach(node => {
        switch (node.type) {
          case 'text-prompt':
            if (node.value) finalPromptParts.push(`The main subject is: "${node.value}".`);
            break;
          case 'setting-diffusion':
            finalPromptParts.push(`Use a diffusion strength of ${node.value}%.`);
            break;
          case 'setting-seed':
            finalPromptParts.push(`Use a generation seed of ${node.value}.`);
            break;
          case 'meta-node':
            finalPromptParts.push(`This is part of a group called "${node.name}".`);
            break;
        }
      });
    }
    const finalImage = await generateImageWithPrompt(
      finalPromptParts.join(' '),
      apiKey,
      newResult.generativeModelInputImage
    );
    newResult.finalImage = finalImage;
  }

  return newResult as ImageGenerationOutput;
}
